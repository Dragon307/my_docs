
------------------------------------------------------------------------

1. 关于线程安全

std::shared_ptr<T> 有两个对象，一个是指向对象的指针 ptr，一个是这个对象的引用计数 ref_count；

虽然这两个值都是原子操作，但是中间却是可以中断的，所以当有多个线程同时读写同一个 shared_ptr<T> 的时候，它不是线程安全的。即允许多线程同时读同一个 shared_ptr<T>，这是安全的。但是不允许这些线程里有任何一个线程对这同一个 shared_ptr<T> 对象进行写操作，只要有任意一个有写行为，就不是线程安全的。比如，一读多写，一写多读，多读多写，全部都是写。这个时候，对 shared_ptr<T> 对象的操作要加锁。

一句话，读安全，写不安全。

shared_ptr<T>的“析构”算写操作。


2. 为什么要用 std::make_shared<T>(....) ？

因为 std::shared_ptr<T>(new Foo(x, y)); 的时候，创建的 Foo() 对象和 std::shared_ptr<T> 对象的 ref_count 分别各需要一次内存分配(堆上的，即new)，共两次分配。我们可以把这两次内存分配合并为一次，即使用 std::make_shared<T>(x,y); 这需要 C++11 的完美转发，把 Foo(x, y) 的初始化列表/参数通过 make_shared(...) 传递给 Foo 的构造函数 Foo(x, y) 。


（以上）See: http://www.cnblogs.com/Solstice/archive/2013/01/28/2879366.html

------------------------------------------------------------------------

虽然借用shared_ptr来实现线程安全的对象释放，但是shared_ptr本身不是100%线程安全的。它的引用记数本身是安全且无锁的，但对象的读写则不是，因为shared_ptr有两个数据成员，读写操作不能原子化。shared_ptr的线程安全级别和内建类型、标准库容器、std：：string一样。

一个shared_ptr对象实体可被多个线程同时读取。
两个shared_ptr对象实体可以被两个线程同时写入，“析构”算写操作。
如果要从多个线程读写同一个shared_ptr对象，那么需要加锁。

上面是shared_ptr对象本身的线程安全级别，不是它管理的对象的安全级别。

要在多个线程中同时访问同一个shared_ptr，正确的做法是用mutex保护。

local copy存在，shared_ptr作为函数参数传递时不必复制。

作者：陈波
链接：https://www.zhihu.com/question/22966055/answer/59637524

来源：知乎

（以上）See: https://www.zhihu.com/question/22966055

------------------------------------------------------------------------