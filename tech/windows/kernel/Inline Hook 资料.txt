
---------------------------------------------------------------------------------

基于API HOOK的剪贴板监控

http://blog.csdn.net/menghjs/article/details/6027757

介绍了 Ring3 层的 剪贴板 API Hook。

---------------------------------------------------------------------------------

Win64 驱动内核编程 -- 22. SHADOW SSDT HOOK

http://blog.csdn.net/u013761036/article/details/66473126

点评：原理还算全面，但逻辑比较混乱，代码也非常混乱，不过还是值得参考一下。
代码看起来是 Win64 的，但还有待进一步验证。


Win64 驱动内核编程 -- 23. Ring0 InLineHook 和 UnHook

http://blog.csdn.net/u013761036/article/details/66477613

简单介绍了 INLINE HOOK 的原理，已经汇编引擎的作用。


Win64 驱动内核编程 -- 24. 64位驱动里内嵌汇编

http://blog.csdn.net/u013761036/article/details/66477711

---------------------------------------------------------------------------------

详谈内核三步走 Inline Hook 实现

http://blog.csdn.net/rrrfff/article/details/6690818

仅仅只介绍了 x86 模式下的 inline hook，但是介绍了下面几个要点：

--------------------

说明三点：

1、堆栈平衡是重中之重，参数压栈也需要格外注意；

2、Ring 0 模式下内存是不允许写的，需要去除写保护，设置 CR0 寄存器；

3、提高中断级别到 DPC，禁止内核里的线程切换； (使用 KeRaiseIrqlToDpcLevel() 函数)

--------------------

这种方法就是通过已导出函数定位未导出函数通常使用的方法，具有通用性。


---------------------------------------------------------------------------------

x64 windows下的inline hook

http://blog.csdn.net/lactoferrin/article/details/7216207

介绍了 x64 下 inline hook 的整个流程，原理和细节，很有实战意义。

这个仅作为学习资料，在正式场合请使用 Detours(x64要钱) 或免费的 N-CodeHook 。

2012-01-27 17:48

---------------------------------------------------------------------------------

x86 的控制寄存器 CR0,CR1,CR2,CR3

http://www.cnblogs.com/ahuo/archive/2009/02/10/1387816.html

x64 模式下的 cr0 设置说明

http://www.mouseos.com/arch/005.html

---------------------------------------------------------------------------------

Inline Hook Sysenter(绕过绝大多数的rootkit检测工具的检测)

http://www.blogfshare.com/sysenter-inline-hook.html

介绍了一种绕过一般的 rootkit 检测工具的 Inline Hook 方法。

---------------------------------------------------------------------------------








---------------------------------------------------------------------------------

[分享]老文章系列：过 Patchguard 的梗

http://bbs.pediy.com/thread-187214.htm

---------------------------------------------------------------------------------

KeServiceDescriptorTable 结构及获取 (根据这篇文章更新了 x64 模式下 KeServiceDescriptorTable 的结构定义)

http://blog.csdn.net/zkzqlove/article/details/21236243

---------------------------------------------------------------------------------

x64 下的 KeServiceDescriptorTable 结构定义

See: http://www.fx114.net/qa-62-58850.aspx

在 64 位系统，内核函数开头地址的低四位一般是0，形如: xxxxxxxx`xxxxxxx0，这一特征在 SSDT 表中有很强大的引用，SSDT 表在 64 位系统于 32 位系统有较大的差别。

以下是在 64 位系统下的 KeServiceDescriptorTable：

kd> dp KeServiceDescriptorTable

fffff800`0117bb80   fffff800`01076e00 00000000`00000000
fffff800`0117bb90   00000000`00000128 00000000`00000000

表的第二项于第四项都为 0，这两项在 32 位系统下分别对应 ServiceCounterTableBase 与 ParamTableBase 。

SSDT 表还是同 32 位系统每 4 字节表示一项，由于函数的起始地址最低四位都是 0，所以微软将 SSDT 中的低四位用来记录这个函数有多少个参数。
并且由于表的每一项都为四个字节，保存的就不可能是绝对地址，而是相对 KeServiceDescriptorTable 表的地址。

所以地址计算方法如下：

FuncAddr = (KeServiceDescriptortable + [KeServiceDescriptortable + index * 4]) & 0xFFFFFFF0

用虾窝中的公式，尝试了一下，果然找到了正确的地址。

---------------------------------------------------------------------------------

Shadow SSDT x64

http://www.xuebuyuan.com/1858119.html

---------------------------------------------------------------------------------

