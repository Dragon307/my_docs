
-----------------------------------------------------------------------------

Windows Driver Samples (WDK Samples)

https://github.com/Microsoft/Windows-driver-samples.git

minifilter 的例子代码在 /filesys/miniFilter 下面。

-----------------------------------------------------------------------------

Windows SDK 下载

https://developer.microsoft.com/zh-cn/windows/downloads/sdk-archive

目前最新的Windows SDK 版本是：Windows 10 SDK (10.0.14393.0)

注：Windows SDK 和 Windows Driver Kit (WDK) 版本号必须要一致，而且必须先装 Windows SDK 再装 WDK，否则 VisualStudio 无法正常使用新安装的 WDK ！

-----------------------------------------------------------------------------

Windows Driver Kit (WDK) 介绍和向导

https://msdn.microsoft.com/en-us/library/windows/hardware/ff557573(v=vs.85).aspx

Windows Driver Kit -- Windows 驱动程序工具包 (WDK)

https://developer.microsoft.com/zh-cn/windows/hardware/windows-driver-kit

目前最新的Windows SDK 版本是：Windows 10 WDK (10.0.14393.0)

---------------------------------------------------

Windows Driver Kit (WDK) 10.0.x (适用于 VS 2015)

https://go.microsoft.com/fwlink/p/?LinkId=526733

支持的操作系统：

Windows 10
Windows 8.1
Windows 8
Windows 7
Windows Server 2016
Windows Server 2008 R2

WDK 8.1.x (适用于 Windows 8.1、8 和 7 驱动程序, 适用于 VS 2013)

https://go.microsoft.com/fwlink/p/?LinkId=393659

WDK 7.1.0（适用于 Windows XP 驱动程序)

https://www.microsoft.com/download/confirmation.aspx?id=11800

GRMWDK_EN_7600_1.ISO

https://download.microsoft.com/download/4/A/2/4A25C7D5-EFBE-4182-B6A9-AE6850409A78/GRMWDK_EN_7600_1.ISO

-----------------------------------------------------------------------------

File System Minifilter Drivers

https://msdn.microsoft.com/en-us/windows/hardware/drivers/ifs/file-system-minifilter-drivers

微软 minifilter 的官方文档首页

-----------------------------------------------------------------------------

Windows文件系统过滤管理器之微过滤器驱动开发指南

http://blog.csdn.net/celestialwy/article/details/694044

简单评价：转载的文章，编辑得还不错。挺长的，内容比较繁杂，不太容易懂，需要有基础才能看懂，但也可以看看。


节选：

此文的原文是《Filter Driver Development Guide》，出自微软的网站。我在以下这个地址下载得到此文:

http://download.microsoft.com/download/e/b/a/eba1050f-a31d-436b-9281-92cdfeae4b45/FilterDriverDeveloperGuide.doc

我尽量在翻译中使文章保持原貌。如果您认为此文无法理解，建议您首先阅读旧的文件过滤驱动的相关资料。我认为必须有文件系统和windows驱动的相关知识，才能阅读此文。


-----------------------------------------------------------------------------

MiniFilter 文件系统学习

http://blog.csdn.net/zhuhuibeishadiao/article/details/51229122

简单评价：还不错，各种文章整理在一起，稍微有点杂乱，但覆盖面比较广，值得一看。

-----------------------------------------------------------------------------

'fltKernel.h' missing when trying to build driver Visual Studio 2012?

http://stackoverflow.com/questions/31859483/fltkernel-h-missing-when-trying-to-build-driver-visual-studio-2012

Folder: C:\Program Files (x86)\Windows Kits\8.0\Include\km

I assume that's with the Windows 8 WDK? Just make sure that the header was installed in your kits header directory ("C:\Program Files (x86)\Windows Kits\8.0\Include\km"). Also note that fltKernel.h is a kernel mode header, so you can only include it in kernel mode driver projects.

If the header is missing from your installation, I'd recommend reinstalling the WDK. If it is not missing and it still isn't found for some reason, you could try manually adding its absolute path to your list of included headers to see if it fixes the issue. If that works (it should), then you can figure out why it was missing from your include path in the first place.


-----------------------------------------------------------------------------

Minifilter微过滤框架：框架介绍以及驱动层和应用层的通讯

http://blog.csdn.net/arvon2012/article/details/7926366

简单评价：还不错，文章不长，比较初级的介绍，可以看看。

其他转载地址：http://www.cnblogs.com/findumars/p/6012381.html


节选：

minifilter 是 sfilter 后微软推出的过滤驱动框架。相比于 sfilter，他更容易使用，需要程序员做的编码更简洁。

系统为 minifilter 专门制作了一个过滤管理器，这个管理器本身其实是一个传统过滤驱动，它向 minifilter 的使用者提供了许多接口，让原本复杂的文件过滤驱动变得方便简单。之所以简单是因为传统的过滤驱动把大量的工作放在绑定设备上，而现在这些工作都交给 minifilter 中的过滤管理器来完成。

缺点：纯粹的使用 minifilter 提供的接口看不见设备对象和 IRP 的，所以编程自由度不大。


对 minifilter 的编写的第一步是向过滤管理器注册一个微过滤器，这个未过滤器是一个组件，包含了一些在文件操作的时候可能需要的回调函数。

驱动入口中最简单的版本是只包含两个函数：注册函数和开始函数。


-----------------------------------------------------------------------------

Minifilter的动态安装、加载及卸载

http://www.cnblogs.com/js2854/archive/2011/04/03/sysload.html

简单评价：如题，Minifilter 驱动的动态安装，加载和卸载，评论里有讨论自动启动的处理方法。

-----------------------------------------------------------------------------

[MiniFilter]驱动隐藏文件夹的实现（支持Win7）

http://www.cnblogs.com/js2854/archive/2010/11/03/HideDir.html

说明：WinXP 和 Win7 以上版本的代码是不一样。

-----------------------------------------------------------------------------

File System Minifilter Drivers（文件系统微型过滤驱动）入门

http://www.cnblogs.com/monotone/p/4184219.html

-----------------------------------------------------------------------------

Windows Minifilter驱动 - 加载顺序 （2）

http://blog.csdn.net/zj510/article/details/39345479

驱动启动类型

看MSDN: http://msdn.microsoft.com/en-us/library/windows/hardware/ff557272(v=vs.85).aspx

vs2013默认使用的是SERVICE_DEMAND_START。 也就是说系统重启后minifilter不会被加载。需要通过Pnp管理器或者SCM来启动。比如使用命令sc start myminifilter。

当windows启动的时候，SERVICE_BOOT_START和SERVICE_SYSTEM_START的minifilter驱动会被自动加载。SERVICE_BOOT_START比SERVICE_SYSTEM_START的驱动更早被加载。MSDN:However, no system-start driver is loaded until after all boot drivers have been loaded.

对于同一种类型的驱动，加载顺序就看他们所属的组了。

-----------------------------------------------------------------------------

Windows Minifilter驱动 - 获取进程ID, 进程名字和线程ID （5）

http://blog.csdn.net/zj510/article/details/39476171

-----------------------------------------------------------------------------

Win10 下 VS2015（WDK10）驱动开发环境配置

http://blog.csdn.net/liuyez123/article/details/50857621

简单评价：有较为详细的使用 VS2015(WDK 10) 连接远程调试机（或虚拟机）的步骤介绍。

非常推荐，虽然很乱，但是还算是详细的，是比较有参考意义的文章，但弄懂以后，最好自己重新归纳整理一下。

-----------------------------------------------------------------------------

MSDN 上关于 WinDBG 的手册

http://www.cnblogs.com/long123king/p/3875145.html

这其实是 WinDBG 的命令一览表，还不错，不过命令说明是英文的，可以当作工具来查询。

命令分类：

Basic Commands
Meta commands
Kernel Mode Extensions
General Extensions
User Mode Extensions

据说是参考这个网址的：

http://msdn.microsoft.com/en-us/library/windows/hardware/ff540507(v=vs.85).aspx

-----------------------------------------------------------------------------

Windows 内核调试 WinDBG 原理浅析

http://dragonsn.bokee.com/502510.html

CSDN 转载的版本：

http://blog.csdn.net/zht_304/article/details/5726492

-----------------------------------------------------------------------------

WinDBG 实时打印 Windows 驱动或者内核信息的方法
http://blog.csdn.net/md521/article/details/37704363

在下面一点，有详细的提要说明。

-----------------------------------------------------------------------------

在 Windows 7 用 WinDBG 调试时显示 KdPrint 信息

http://blog.chinaunix.net/uid-701988-id-373702.html

在注册表 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager 下面，
新建一项 Debug Print Filter，
新建一个DWORD值，名称为 “DEFAULT”，(注意：必须全部是大写)
值为8。

重启操作系统即可。

例如：

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]
"DEFAULT"=dword:00000008

其他操作系统
----------------

WinXP:

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]
"DEFAULT"=dword:00000008

Vista:

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]
"DEFAULT"=dword:0000000f

Windows 7:

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]
"DEFAULT"=dword:ffffffff

-----------------------------------------------------------------------------

在 HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter 下面：

新建 DEFAULT（DWORD类型）：

DEFAULT  0x08       输出 xxx_INFO_LEVEL, xxx_ERROR_LEVEL 信息

DEFAULT  0x0f       输出所有级别的信息

DEFAULT  0xffffffff 输出所有的信息

修改后，要重启操作系统才能生效。

-----------------------------------------------------------------------------

WinDBG 实时打印 Windows 驱动或者内核信息的方法

http://blog.csdn.net/md521/article/details/37704363

当我们用 WinDBG 调试 Windows 驱动或者内核时，总是需要查看相关 Log 信息，那么如何在WinDBG中实时打印 Windows 驱动或者内核信息呢？

Windows 驱动包提供了驱动或者内核打印接口：DbgPrintEx.

对于 KMDF 驱动(内核态驱动)，对应的打印接口是 KdPrint 或者 KdPrintEx，其实这两个接口是 DbgPrintEx 的特殊类型或者特殊定义而已。
对于 UMDF 驱动(用户态驱动)，没有专门的打印接口，可以使用 DbgPrint(DbgPrintEx的特殊定义)，或者直接使用 DbgPrintEx 接口，当然还可以使用 Win32 的调试接口 OutputDebugString。

不过，当用 WinDBG 调试 Windows 驱动或者内核时，如何让上述打印接口实时的显示在WinDBG的调试窗口呢?

1. 打开 WinDBG 调试软件，新建内核调试 WorkSpace(CTRL + K)；
2. 加载 Windows 驱动或者内核符号表文件(CTRL + S);
3. 在上述步骤中，选择符号表所载的文件夹，然后选中 Reload ，确定；

4. 当 WinDBG 调试窗口加载符号表未出现错误信息时，在 WinDBG 中命令行中输入以下命令：

    ed kd_default_mask 0xffffffff       // 不区分大小写，用于打开 Windows 驱动或者内核调试筛选器、

5. 在 WinDBG 命令行输入g，回车运行。
6. 此时如果 WinDBG 没有任何错误信息，并且调试的正好是相关 Windows 驱动程序或者内核时，就会输出 Debug 信息。

-----------------------------------------------------------------------------

Windbg 下无法显示 DbgPrint 输出的信息

http://blog.csdn.net/happy987818/article/details/50516236

有对 DbgPrintEx() 函数的详细参数说明，同时也转载了别人在 Vista 系统下的分析及解决过程，总得来说值得一看。

转载地址，Vista 下的分析及解决过程：http://blog.csdn.net/xw_1120/article/details/5055030

总结如下：

1、Win7/Vista 下确实需要修改调试信息过滤的键值（不知道我为什么没成功- -），而且该修改竟然存在 wxp 和 wlh 两个版本（网站上并无说明），如果自己修改不成功可以借助别人做的工具。

2、修改过键值后，DbgPrintEx() 函数用于 WDM 驱动调试信息的编写，而 DbgPrint() 函数用于 NT 驱动。

3、关于 DbgPrintEx() 在 WDM 驱动源代码下有时会无法链接成功的问题，上面已有说明，解决方法是将“DRIVERTYPE=WDM”一句删掉。

4、关于 build 工具，使用不同版本要配合相应的键值的修改，这样才能成功打印调试信息。

-----------------------------------------------------------------------------

Debugger 里面如何得到 DbgPrintEx 的输出

http://advdbg.org/forums/2269/ShowPost.aspx

你是在Driver里面用的DbgPrintEx,我当时是断在了ntdll!DbgPrintEx里面了,我跟了一下,发现,这个里面确实有一个filter的,就是后面这个,
ntdll!NtQueryDebugFilterState,后者是一个SysCall,根据DbgPrintEx的参数ComponentId来做Mask, 貌似设置nt!Kd_WIN2000_Mask成0xffffffff后,
所有的component都不会被mask,也就会被show出来了.

-----------------------------------------------------------------------------

DbgPrintEx 的执行流程和参数说明：
http://blog.csdn.net/vins_security_lab/article/details/47294225

    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_ERROR_LEVEL, "Error!\n");
    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_WARNING_LEVEL, "Warning!\n");
    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_TRACE_LEVEL, "Trace!\n");
    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_INFO_LEVEL, "Info!\n");

    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_BEFORE_LEVEL, "Before!\n");
    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_MIDDLE_LEVEL, "Middle!\n");
    DbgPrintEx(DPFLTR_FASTFAT_ID, DPFLTR_AFTER_LEVEL, "After!\n");

文章有介绍 DbgPrintEx 的 Filter 机制的(Mask)组合原理图，可以了解一下。

------------------------------------------------------

WinDBG 实时打印 Windows 驱动或者内核信息的方法

http://blog.csdn.net/md521/article/details/37704363

(上面有个版本，有更详细的摘要)

4. 当 WinDBG 调试窗口加载符号表未出现错误信息时，在 WinDBG 中命令行中输入以下命令：

   ed kd_default_mask 0xffffffff       // 不区分大小写，用于打开Windows驱动或者内核调试筛选器

------------------------------------------------------

minispy!DriverEntry

1: kd> eb nt!Kd_WIN2000_Mask 0

1: kd> dyd nt!Kd_WIN2000_Mask
           3          2          1          0
          10987654 32109876 54321098 76543210
          -------- -------- -------- --------
82948bbc  00000000 00000000 00000000 00000000  00000000

1: kd> eb nt!Kd_FASTFAT_Mask 0y1010000

1: kd> dyd nt!Kd_FASTFAT_Mask
           3          2          1          0
          10987654 32109876 54321098 76543210
          -------- -------- -------- --------
82956f2c  00000000 00000000 00000000 01010000  00000050

------------------------------------------------------

dyd nt!Kd_WIN2000_Mask

dyd nt!Kd_DEFAULT_Mask
dyd nt!Kd_FASTFAT_Mask

0: kd> dyd nt!Kd_DEFAULT_Mask
           3          2          1          0
          10987654 32109876 54321098 76543210
          -------- -------- -------- --------
83d4aec8  11111111 11111111 11111111 11111111  ffffffff

ed nt!Kd_DEFAULT_Mask 0xffffffff
dyd nt!Kd_DEFAULT_Mask


dyd nt!Kd_FLTMGR_Mask

0: kd> dyd nt!Kd_FLTMGR_Mask
           3          2          1          0
          10987654 32109876 54321098 76543210
          -------- -------- -------- --------
83d4adf0  00000000 00000000 00000000 00000000  00000000

eb nt!Kd_FLTMGR_Mask 0y1010000

eb nt!Kd_FLTMGR_Mask 0y11111111   (用于使用的是 eb 命令，最大只能8个bit)

ed nt!Kd_FLTMGR_Mask 0xffffffff

-----------------------------------------------------------------------------

先复制一份当前的启动配置：

C:\> bcdedit copy {current} "Windows 7 Debug With Serial"

会显示如下信息：
The entry was successfully copied to {cafcc464-ccc7-11e6-97a2-98d472d6dd37}.

注：除了{current}以外，还有个变量是{default}。

然后打开新启动配置的调试模式，下面这两个命令是等价的：

C:\> bcdedit /debug {cafcc464-ccc7-11e6-97a2-98d472d6dd37} on
C:\> bcdedit /set {cafcc464-ccc7-11e6-97a2-98d472d6dd37} debug yes

设置允许测试驱动签名（即不强制检测是否为微软正规的驱动签名）：
C:\> bcdedit /set {cafcc464-ccc7-11e6-97a2-98d472d6dd37} testsigning on

或者启动的时候按 F8，选项中选择“不检测驱动签名”。

C:\> bcdedit /dbgsettings {cafcc464-ccc7-11e6-97a2-98d472d6dd37} serial debugport:1 baudrate:115200

debugport:1 表示使用 COM1 接口。

查看 debug 设置：

C:\> bcdedit /dbgsettings {cafcc464-ccc7-11e6-97a2-98d472d6dd37}

如果使用的是 HyperV 虚拟机,可以这样设置：（我也不知道该何时用这个命令，因为虚拟机本身自己就可以通过界面修改串口设置。这个命令是我从 bcdedit 的帮助信息里看到的，如果不知道怎么用请忽略。）

C:\> bcdedit /hypervisorsettings {cafcc464-ccc7-11e6-97a2-98d472d6dd37} serial debugport:1 baudrate:115200

debugport:1 表示使用 COM1 接口。

查看当前的启动加载器的配置:

C:\> bcdedit /enum {current}

Windows 启动加载器
-------------------
标识符                  {current}
device                  partition=C:
path                    \Windows\system32\winload.exe
description             Windows 7 Debug With Serial
locale                  zh-CN
inherit                 {bootloadersettings}
recoverysequence        {cafcc462-ccc7-11e6-97a2-98d472d6dd37}
recoveryenabled         Yes
testsigning             Yes
osdevice                partition=C:
systemroot              \Windows
resumeobject            {cafcc460-ccc7-11e6-97a2-98d472d6dd37}
nx                      OptIn
debug                   Yes

列出所有启动管理器和启动加载器的信息：

C:\> bcdedit /enum

-----------------------------------------------------------------------------

示例:

C:\> bcdedit /copy {current} /d "Windows 7 Debug With Serial"
已将该项成功复制到 {cafcc464-ccc7-11e6-97a2-98d472d6dd37}。

C:\> bcdedit /debug {cafcc464-ccc7-11e6-97a2-98d472d6dd37} on
操作成功完成。

C:\> bcdedit /dbgsettings
debugtype               Serial
debugport               1
baudrate                115200
操作成功完成。

C:\Windows\system32>

-----------------------------------------------------------------------------

开机按 F8，可以选择“跳过驱动签名”。

关闭强制驱动签名的命令为:

bcdedit.exe -set loadoptions DDISABLE_INTEGRITY_CHECKS

See: https://zhidao.baidu.com/question/628350255653791564.html

-----------------------------------------------------------------------------

转载: 循序渐进学Minifilter（微过滤器） 之 一 （开篇）

http://blog.csdn.net/lostspeed/article/details/9234887

KdBreakPoint();

-----------------------------------------------------------------------------

【原创】minifilter通讯之简单示例之一

http://bbs.pediy.com/showthread.php?t=186931

/*
  这里要注意:
    1. 数据地址的对齐.
    2. 文档建议使用:try/except处理.
    3. 如果是64位的驱动要考虑32位的EXE发来的请求.
*/

status = FltCreateCommunicationPort(gFilterHandle, &g_ServerPort, &oa, NULL, ConnectNotifyCallback, DisconnectNotifyCallback, MessageNotifyCallback, 1);

-----------------------------------------------------------------------------

（译文）WDK Minifilter 自带示例的简要说明

http://blog.csdn.net/jykj_007/article/details/5421397

英文原文地址：http://msdn.microsoft.com/en-us/library/dd445225.aspx

翻译整理如下(原来的翻译格式混乱，不完整，已修复了一些)：

cancelSafe minifilter sample

描述：如果你要使用 cancel-safe 队列（什么意思？），就用 cancelsafe minifilter sample吧。
操作原理：当 cancelsafe minifilter 附属于一个卷时，将初始化一个 cancel-safe 队列。当这个 minifilter 销毁时，监控器读取通过I/O栈的操作。如果这个读操作已经在一个名叫 csqdemo.txt 文件上运行，这个操作将被排到 cancel-safe 队列，排队操作将在短暂的停顿（通过一个单独的运行在系统上下文的工作线程）之后完成。（去死啊，搞那么多that）

minispy minifilter sample

描述：本示例是一种监控和记录任何 I/O 以及重现系统内部事务活动的工具。这个例子类似大名鼎鼎的 filespy，不过它是用 minifilter 实现的。
操作原理：minispy 由用户模式和内核模式组成，内核模式组件注册（相当于各种利用过滤管理器进行 I/O 和事务操做）的回调函数，
这些回调函数帮助 minispy 记录任何系统的 I/O 和事务动作事件。当一个用户能够访问记录信息时，这个记录信息通过用户模式组件，
即可以输出到屏幕上也可以输入到磁盘上的 log 文件里要观察一个设备上的 I/O 活动，你必须明确地指定 minispy 和这个设备的联系，同样，
也可以要求 minispy 停止对一个特定设备记录日志。

ctx minifilter sample

描述：本例用来说明如何指派你的 minifilter 和实例、文件、流或流句柄的上下文。
操作原理：ctx minifilter 展示如何从和实例、文件、流或流句柄指派上下文或移除上下文，无论一个或多个对象被创建，ctx 都会指派一个上下文。当指派一个文件的上下文时，例子同样创建一个流和流句构的上下文。所有的上下文将完全被过滤管理器用 minifilter 提供的回调函数删除。

passThrough minifilter sample

描述：passThrough minifilter 说明如何为不同类型的 irp 指定回调函数。
操作原理：passThrough minifilter 没有任何真正的功能。对于每种 I/O 操作,预回调和后回调函数同样被调用，这些回调函数仅仅在堆栈的下一个过滤器之前。

fastfat file system

描述: 你可以用它来写全新的文件系统（if you want....）
操作原理：I had never think of to write a new file system...even the Boss kill me

scanner minifilter sample

描述: 本例适用于有志于写检测文件数据过滤器的“developers”, 尤其是反病毒就是属于这个领域滴（貌似卡巴斯基就用到 minifilter）！
操作原理：sanner 包括用户模式和内核模式组件，内核组件识别合适的时机去扫描一个文件的数据并且传递数据到用户模式组件做更多的确认。用户模式组件创建一个线程的编号去等待内核组件的确认？？在扫描到脏数据字符后，用户模式发送一个合适的反应给内核模式组件。

内核模式组件仅用特定的扩展名（extensions）扫描文件。文件首先在成功的打时扫描。如果文件被写访问打开，扫描将在文件关闭前重新执行。扫描同样可以运行在将被写入到文件的数据上，当数据里发现脏字符串时写将被拒绝。当脏字符在文件关闭期间发现，打印一个 debug 消息。

swapbuffers minifilter sample

描述: swapbuffer minifilter 展示如何交换读和写数据之间的缓存。这项技术在加密过滤时相当有用，因为你必须在数据写到磁盘上之前加密，在数据从磁盘上读取后解密。由于加解密必须透明，你不能直接使用系统提供的缓存，因此中间缓存是必须引进滴。
操作原理：swapbuffer minifilter 在读/写或目录控制操作前引进一个新缓存，对应的操作随即运行在新缓存，以代替初始提供的缓存，在操作完成后，新缓存的内容被拷贝回初始缓存。

-----------------------------------------------------------------------------

Windows Driver Kit (WDK) 8.0 Samples (下载地址）

This samples pack contains all the official Windows Driver Kit code examples prepared for use with Visual Studio 2012 and the Windows Driver Kit (WDK) 8.0.

https://code.msdn.microsoft.com/windowshardware/windows-driver-kit-wdk-80-e3161626

这是 Visual Studio 2012 下用的，配合 WDK 8.0，也行有时候用得着吧，你可以研究一下 WDK 8.0 的例子跟最新的 WDK 例子的有哪些区别（改变）。

-----------------------------------------------------------------------------

WinDBG + VM 调试环境的搭建

http://blog.csdn.net/eric491179912/article/details/6090472

其实还不错，虽然没有什么用，但很多我想说的，他也说到了，写文章的话值得参考一下一些内容。

例如：

3. 我可以在GuestOS的boot.ini文件更改那个COM口吗？比如把COM1改为COM2？ （郭子注：这一点并不一定正确，待求证，至少 VirtualBox 里不一定是这样的。）

不可以的，VMware会把虚拟出的这个COM口总是定义为com1。GuestOS的其他COM口都得让位。

7. 一定要这样创建一个WinDBG的快捷方式才能进行调试吗？

不是的，我们完全可以先正常运行WinDBG，然后选择菜单“File”--->“Kernel Debug...”，然后会弹出以下对话框：

-----------------------------------------------------------------------------

Windows 文件过滤驱动经验总结

http://bbs3.driverdevelop.com/read.php?tid=98728&fid=39

挺实用的经验分享，还没验证，目测还不错。

-----------------------------------------------------------------------------

http://bbs3.driverdevelop.com/read.php?tid=108945&fid=39

偶然发现 FltGetFileNameInformation 方法有清缓存的功能，真是又安全又方便。

调用方法：FltGetFileNameInformation( Data,
                                     FLT_FILE_NAME_NORMALIZED |
                                     FLT_FILE_NAME_QUERY_ALWAYS_ALLOW_CACHE_LOOKUP,
                                     &nameInfo );

-----------------------------------------------------------------------------

http://bbs3.driverdevelop.com/simple/?t121675.html

双缓存也好几种做法, 公认的是layerfsd, 简单点的就是自建.

-----------------------------------------------------------------------------

【分享】minifilter透明加解密源码 (作者：shenshui)

http://bbs3.driverdevelop.com/read.php?tid=119736

文件名：encryption_on_the_fly.zip

现在很多做透明加解密的初学者都比较困惑，不知从何下手，我也是如此，从什么都不会开始，慢慢肯文件系统内幕，到OSR上面请教，四个月的时间还是收获颇丰。其实真正研究以后会发现，很多都是体力活，要不断的去跟踪文件的操作流程。在这里发一个基于minifilter的透明加解密的驱动源码仅供大家参考，其中也实现了对文件标识的处理，文件标识放在文件尾部。算是抛砖引玉吧。坦白的说，这个代码并不稳定（偶尔与norton杀毒软件会有冲突），但是我觉得整个流程是正确的，可能有些细节还没有考虑清楚，我觉得对初学者还是有一定帮助吧，当然大虾们可以跳过，呵呵。另外，有关加解密算法的代码由于不是我写的，也不好公开，所以我把相关代码用“\\\”给注释掉了（但没有去掉），请大家见谅，不过不会对整个流程产生影响。大家可以重点看一下各个派遣函数的实现。

欢迎大家拍砖，觉得有点意思就顶一下啊，在看代码的过程中如果有什么好的建议，也希望能告诉我。

最后非常感谢XiangXiangRen,zzbwang,neak47等网友在这段时间内对我的帮助。XiangXiangRen的书以及zzbwang的帖子对我完成这项工作有很大的帮助和参考价值，在此谨与大家分享。

编译环境：WDK6001.18002 XP x86

-----------------------------------------------------------------------------

sfilter透明加解密源代码  (标题：透明加解密源程序分享(重新上传了))

http://bbs3.driverdevelop.com/read.php?tid=121897&fid=39

文件名：源程序.zip

这个程序是在 tooflat 的那段经典程序上写的，由底层文件系统过滤驱动和上层应用程序组成，全部附有源码。

功能：保证机密文件夹下文件以密文形式存在，只有机密进程才能对其进行解密操作，加密规则在应用程序中指定。

此程序只是个例子，希望对新手有所帮助，高手就别看了。

使用方法：编译安装驱动程序重启，接下来将上层应用程序运行起来，根据界面设置加密规则，比如我将机密进程表中的 WINWORD.EXE 勾上，再将机密文件夹表中的 D:\EN_TEST 勾上，然后点击确定，那么 D:\EN_TEST 目录下的所有文件都是以密文形式存在，只有 WINWORD.EXE 可以正常打开 WORD 文档。（注意机密进程表和机密文件夹表中的项可以自己通过添加按钮添加）。

-----------------------------------------------------------------------------

miniFilter下，文件透明加密文件大小返回的问题

http://bbs3.driverdevelop.com/read.php?tid=120486&fid=39&page=1

我的透明加密加密标志放在文件头部，长度4K。现在经过测试，记事本和Office系列，AutoCAD都能正常加密解密。就是UltraEdit，写字板，打开文件后，文件内容是解密后的正确数据，但是，在正文后面，会有4K的空白区域，我觉得是这两个应用取到了实际的文件大小。

根据论坛上查找到的资料，我处理了IRP_MJ_QUERY_INFORMATION 的FileAllInformation(StandardInformation.EndOfFile 和 AllocationSize)，FileAllocationInformation(AllocationSize)，FileValidDataLengthInformation(ValidDataLength），FileStandardInformation（EndOfFile 和AllocationSize），FileNetworkOpenInformation（AllocationSize，EndOfFile），IRP_MJ_DIRECTORY_CONTROL（FileBothDirectoryInformation）。跟踪观察，这些返回的数据都是我想要的结果。可为什么UltraEdit和写字板还是能够获取到实际文件的大小，搞不懂，难道他们是通过其他途径得到的文件大小？

-----------------------------------------------------------------------------

WIN7 X64 SSDT函数获得

http://www.52pojie.cn/forum.php?mod=viewthread&action=printable&tid=44156

x86下：

FuncAddr = ([KeServiceDescriptortable + index * 4] + KeServiceDescriptortable) & 0xFFFFFFF0

所以 WIN7 X64 下应该是:

    FuncAddr = ([KeServiceDescriptortable + index * 4] >>4 + KeServiceDescriptortable) & 0xFFFFFFF0.

-----------------------------------------------------------------------------

x64 内核编程小窥 - SSDT HOOK笔记

原文链接: http://bbs.pediy.com/showthread.php?t=194447

转载链接：http://czy0538.lofter.com/post/1ccbdcd5_4079090

写得还不错，并且提供了 x64 下计算 KeServiceDescriptortable 的代码。

-----------------------------------------------------------------------------

WinDBG

Symbol Path:

srv*C:\SymbolCache*http://msdl.microsoft.com/download/symbols

srv*C:\SymbolLocal*http://msdl.microsoft.com/download/symbols

srv*C:\Symbols*http://msdl.microsoft.com/download/symbols


-----------------------------------------------------------------------------

Win 10 下 VS2015（WDK 10.0）驱动开发环境配置

http://blog.csdn.net/liuyez123/article/details/50857621

配置 WDKRemoteUser 的主要参考文章.

-----------------------------------------------------------------------------

Windows 7 账号自动登陆

Turn off Automatic login with Windows 7

See: http://superuser.com/questions/21617/turn-off-automatic-login-with-windows-7

Press Windows R. A command box should appear. Type control userpasswords2 and hit the enter key. This should display the User Accounts screen in Windows 7. Select the user account in the main table and uncheck the “Users must enter a user name and password to use this computer". A click on the Apply button will open the Automatically Log On window. Enter the password and confirm it to add the password to the system so that it does not need to be entered during logon.

命令行里输入：control userpasswords2，然后把 “要使用本机，用户必须输入用户名和密码” 的单选框的勾去掉，
然后点“应用”按钮，就会弹出一个叫“自动登陆”的窗口，在这个界面里输入用户名，和两次确认密码，这样就可以使用
这个用户名自动登陆 Windows 7 了。

其他一些设置请看这个配置界面的其他窗口。

-----------------------------------------------------------------------------

Transparent file encryption on a PC using Cybersafe File Encryption 

http://cybersafesoft.com/blog/transparent-file-encryption-on-a-pc/

一篇关于透明加密的加密和解密过程的文章, 不错, 值得一看.

-----------------------------------------------------------------------------

File Encryption Driver Development with per Process Access Restriction

https://www.apriorit.com/dev-blog/371-file-encryption-driver-development-with-per-process-access-restriction

一篇关于使用 minifilter 做透明加密和 文件系统缓存 的之间的机制和原理的文章, 很不错, 值得一看.

-----------------------------------------------------------------------------

<fltKernel.h>

Line 1048:

//
//  Flag Bit definitions for the Flags variable of FLT_CALLBACK_DATA
//

typedef ULONG FLT_CALLBACK_DATA_FLAGS;

    //
    //  Flags passed to mini-filters
    //

    //
    //  This mask designates the flags that describe the the type of i/o
    //  and parameters
    //
    #define FLTFL_CALLBACK_DATA_REISSUE_MASK           0x0000FFFF

    //
    //  The below 3 flags are mutually exclusive.
    //  i.e. only ONE and exacly one hould be set for the callback data.
    //  Once set they should never change
    //
    #define FLTFL_CALLBACK_DATA_IRP_OPERATION           0x00000001    // Set for Irp operations
    #define FLTFL_CALLBACK_DATA_FAST_IO_OPERATION       0x00000002    // Set for Fast Io operations
    #define FLTFL_CALLBACK_DATA_FS_FILTER_OPERATION     0x00000004    // Set for Fs Filter operations
    //
    //  In principle this flag can be set for any operation. Once set it shouldn't change
    //
    #define FLTFL_CALLBACK_DATA_SYSTEM_BUFFER           0x00000008    // Set if the buffer passed in for the i/o was a system buffer



    //
    //  Below flags are relevant only for IRP-based i/o - i.e. only
    //  if FLTFL_CALLBACK_DATA_IRP_OPERATION was set. If the i/o was reissued
    //  both flags will necessarily be set
    //
    #define FLTFL_CALLBACK_DATA_GENERATED_IO            0x00010000    // Set if this is I/O generated by a mini-filter
    #define FLTFL_CALLBACK_DATA_REISSUED_IO             0x00020000    // Set if this I/O was reissued

    //
    //  Below 2 flags are set only for post-callbacks.
    //
    #define FLTFL_CALLBACK_DATA_DRAINING_IO             0x00040000    // set if this operation is being drained. If set,
    #define FLTFL_CALLBACK_DATA_POST_OPERATION          0x00080000    // Set if this is a POST operation

    //
    //  This flag can only be set by Filter Manager, only for an IRP based operation
    //  and only for a post callback. When set, it specifies that a lower level driver
    //  allocated a buffer for AssociatedIrp.SystemBuffer in which the data for
    //  the operation will be returned to the IO manager. Filters need to know this
    //  because when they were called in the PRE operation AssociatedIrp.SystemBuffer
    //  was null and as such their buffer is set to UserBuffer and they have no way of
    //  getting the real data from SystemBuffer. Check the IRP_DEALLOCATE_BUFFER flag for
    //  more details on how this is used by file systems.
    //

    #define FLTFL_CALLBACK_DATA_NEW_SYSTEM_BUFFER       0x00100000

    //
    //  Flags set by mini-filters: these are set by the minifilters and may be reset
    //  by filter manager.
    //
    #define FLTFL_CALLBACK_DATA_DIRTY                   0x80000000    // Set by caller if parameters were changed


//
// Below flags are relevant only for IRP-based i/o - i.e. only if FLTFL_CALLBACK_DATA_IRP_OPERATION was set. If the i/o was reissued both flags will necessarily be set.
// 下面的标志仅与基于 IRP 的 i/o 相关 - 例如: 只有当 FLTFL_CALLBACK_DATA_IRP_OPERATION 被设置时。如果 i/o 被重新发布，则两个标志都将被设置。
//
#define FLTFL_CALLBACK_DATA_GENERATED_IO            0x00010000    // Set if this is I/O generated by a mini-filter
#define FLTFL_CALLBACK_DATA_REISSUED_IO             0x00020000    // Set if this I/O was reissued (重新发布)

-----------------------------------------------------------------------------

Windows 驱动开发技术详解笔记(2) -- 字符串与链表

See: http://www.cnblogs.com/forlina/archive/2011/08/11/2134610.html

2）内核模式下各种开头函数的区别

函数开头含义

Cc          Cache manager
Cm          Configuration manager
Ex          Executive support routines
FsRtl       File system driver run-time library
Hal         Hardware abstraction layer
Io          I/O manager
Ke          Kernel
Lpc         Local Procedure Call
Lsa         Local security authentication
Mm          Memory manager
Nt          Windows 2000 system services (most of which are exported as Win32 functions)，例如: NtCreateFile 往往导出为 CreateFile .
Ob          Object manager
Po          Power manager
Pp          PnP manager
Ps          Process support
Rtl         Run-time library
Se          Security
Wmi         Windows Management Instrumentation
Zw          Mirror entry point for system services (beginning with Nt) that sets previous access mode to kernel, which eliminates parametervalidation, since Nt system services validate parameters only if previous access mode is user see Inside Microsoft Windows 2000

-----------------------------------------------------------------------------

Minifilter中 Filter Initiated I/O（过滤器自产生I/O） (翻译)

http://blog.csdn.net/wwwgeyang777/article/details/7011355

-----------------------------------------------------------------------------

Minifilter中Swapping buffers（交换缓冲） (翻译)

http://blog.csdn.net/wwwgeyang777/article/details/7011008

-----------------------------------------------------------------------------

《Filter Driver Developer Guide》

FilterDriverDeveloperGuide.doc

http://download.microsoft.com/download/e/b/a/eba1050f-a31d-436b-9281-92cdfeae4b45/FilterDriverDeveloperGuide.doc

微软官方的 《Filter 驱动开发指南》。

-----------------------------------------------------------------------------

文件的透明加密技术研究与实现-ver1

http://www.doc88.com/p-901293119716.html

基于 PKCS 的文件透明加解密技术的研究与实现

http://www.doc88.com/p-989340877602.html

-----------------------------------------------------------------------------
